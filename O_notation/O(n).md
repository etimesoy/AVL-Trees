1) Поиск: O(logN)
Эта функция начинается с корня и рекурсивно вызывается только у одного из детей (только левого или только правого), 
поэтому каждый уровень дерева будет посещен не более одного раза. А всего уровней = logN.
2) Удаление: O(logN)
Так как это сбалансированное дерево поиска, то высота всегда не будет больше logN.  
Т.о. процедура удаления вершины v из сбалансированного дерева поиска сводится к следующему:
-  нахождению вершины v, которую следует удалить,
-  ее удалению из дерева поиска (с помещением на ее место некторой вершины v'),
-  для каждой вершины ветви дерева от v' до корня следует проверять условие балансировки – если нарушено, 
   то операциями вращения следует произвести балансировку соответствующего поддерева.
3) Вставка: O(logN)
Ищется вершина (высота левого поддерева не равна высоте правого поддерева). 
Происходит балансировка от вставленной вершины до корня. 
Так как высота поддерева не больше logN, то и сложность равна logN.

4) Различие графиков:
Они различаются из-за различий языков. Python стремится к минимальной оценке  
(но при этом другая ситуация порождает максимально возможную сложность). 
А С++ страется держать баланс (в самых различных ситуациях временная сложность различается не сильно) 
и при этом даже в самых худших случаях работает быстрее, чем на языке Python.

P.S. Графики можно найти по ссылке в README.
